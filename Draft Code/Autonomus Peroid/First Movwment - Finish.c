#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in6,    rightPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in7,    leftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  shaft,          sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  left,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  right,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           Tright,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Bright,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightGrab,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftGrab,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Bleft,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Tleft,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// set up pannal
int x;
int rightPotentio;
int leftPotentio;


//Functions


// "liftMove()" is a function to lift move stright
void liftMove(int range){
	// Reset the integrated encoder
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// the loop mesure the left wheel value to calculate
  while(nMotorEncoder[leftMotor] < 1500){
		x = nMotorEncoder[leftMotor];		//display the value of the encoder
		motor[rightMotor] = 90;
    motor[leftMotor] = 90;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


    rightPotentio = SensorValue[rightPotentiometer];
		leftPotentio = SensorValue[leftPotentiometer];

		if(rightPotentio > range){
			motor[rightGrab] = abs(rightPotentio - range)/10;
			}else if (rightPotentio < range){
			motor[rightGrab] = abs(rightPotentio - range)/-10;
		}

		if(leftPotentio > range){
			motor[leftGrab] = abs(leftPotentio - range)/10;
			}else if (leftPotentio < range){
			motor[leftGrab] = abs(leftPotentio - range)/-10;
		}
/////////////////////////////////////////////////////////////////////////////////////////////////////
    if(SensorValue[shaft] < 90){
		  motor[Tright] = 60;
			motor[Bright] = 60;
			motor[Bleft] = 60;
			motor[Tleft] = 60;
		}else {
			motor[Tright] = 15;
			motor[Bright] = 15;
			motor[Bleft] = 15;
			motor[Tleft] = 15;
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	wait1Msec(500);
}


void moveBack(int range){
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	while(abs(nMotorEncoder[rightMotor]) < range){
		motor[rightMotor] = -40;
    motor[leftMotor] = -40;
	}
		motor[rightMotor] = 0;
    motor[leftMotor] = 0;
    wait1Msec(200);
}

void rightTurn(int range){
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	while(abs(nMotorEncoder[rightMotor]) < range){
		motor[leftMotor] = 35;
		motor[rightMotor]= -35;
		if(SensorValue[shaft] > 75){
			motor[Tright] = 15;
			motor[Bright] = 15;
			motor[Bleft] = 15;
			motor[Tleft] = 15;
		}
	}


	motor[leftMotor] = 0;
	motor[rightMotor]= 0;

	motor[Tright] = 0;
	motor[Bright] = 0;
	motor[Bleft] = 0;
	motor[Tleft] = 0;

	wait1Msec(200);
}

void cubeMove(){
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	while(nMotorEncoder[rightMotor] < 980){
		motor[rightMotor]= 90;
		motor[leftMotor]= 90;
	}
		motor[rightMotor]= 0;
		motor[leftMotor]= 0;
		wait1Msec(500);
}




void grab(int range){
	while(SensorValue[leftPotentiometer] > range + 50){
		rightPotentio = SensorValue[rightPotentiometer];
		leftPotentio = SensorValue[leftPotentiometer];

		if(rightPotentio > range){
			motor[rightGrab] = 65;
		}

		if(leftPotentio > range + 70){
			motor[leftGrab] = 65;
		}
	}
}


void leftTurnLift(){

	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	SensorValue[shaft] = 0;

	while(abs(nMotorEncoder[leftMotor]) < 200){

		motor[leftMotor] = -50;
		motor[rightMotor]= 50;
		if(SensorValue[shaft] < 90){
			motor[Tright] = 127;
			motor[Bright] = 127;
			motor[Bleft] = 127;
			motor[Tleft] = 127;
		}else {
			motor[Tright] = 25;
			motor[Bright] = 25;
			motor[Bleft] = 25;
			motor[Tleft] = 25;
		}
	}
	motor[leftMotor] = 0;
	motor[rightMotor]= 0;
	wait1Msec(100);

	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	while(nMotorEncoder[leftMotor] < 750){
		motor[leftMotor] = 90;
		motor[rightMotor]= 90;
		if(SensorValue[shaft] > 85){
			motor[Tright] = 15;
			motor[Bright] = 15;
			motor[Bleft] = 15;
			motor[Tleft] = 15;
		}else {
			motor[Tright] = 0;
			motor[Bright] = 0;
			motor[Bleft] = 0;
			motor[Tleft] = 0;
		}
	}
	motor[leftMotor] = 0;
	motor[rightMotor]= 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void releaseGrab(int range){
	while(SensorValue[leftPotentiometer] < range){
		rightPotentio = SensorValue[rightPotentiometer];
		leftPotentio = SensorValue[leftPotentiometer];

		if(rightPotentio > range){
			motor[rightGrab] = abs(rightPotentio - range)/10;
			}else if (rightPotentio < range){
			motor[rightGrab] = abs(rightPotentio - range)/-10;
		}

		if(leftPotentio > range){
			motor[leftGrab] = abs(leftPotentio - range)/10;
			}else if (leftPotentio < range){
			motor[leftGrab] = abs(leftPotentio - range)/-10;
		}
	}
}

task main()
{

		  SensorValue[shaft] = 0;
	  	liftMove(2000);
	  	moveBack(100);
	  	rightTurn(400);
	  	cubeMove();
	  	grab(700);
	  	leftTurnLift();
	  	releaseGrab(1000);

}
