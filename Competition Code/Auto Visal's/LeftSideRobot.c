#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in6,    rightPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in7,    leftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  shaft,          sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  left,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  right,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           Tright,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Bright,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightGrab,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftGrab,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Bleft,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Tleft,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


/*SET UP PENAL*/
int x;
int rightPotentio;
int leftPotentio;

/******************************************************	SET UP	*********************************************************/
/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This will get the value of the potentiometer*/
void grabValue() {
	rightPotentio = SensorValue[rightPotentiometer]; // set the "rightPotentio" as the value of right potentiometer
	leftPotentio = SensorValue[leftPotentiometer]; // set the "leftPotentio" as the value of left potentiometer
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This is reset the wheels encoder to 0*/
void resetWheels() {
	nMotorEncoder[rightMotor] = 0; // Reset the integrated encoder
	nMotorEncoder[leftMotor] = 0; // Reset the integrated encoder
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This is for more the robot and will slow down when the robot reaches it's half way*/
void moving(int range, int speed) { //function "move" would get input value of "range" of distance in counts and "speed"
	if(abs(nMotorEncoder[rightMotor]) < (range/4)*3.5) { // two of the motors, find average then compare
		motor[rightMotor] = speed; // move with full speed for half way
   	motor[leftMotor] = speed; // move with full speed for half way
	}else {
		motor[rightMotor] = (speed / 4)*3.5; // move with half speed for the next half way
   	motor[leftMotor] = (speed / 4)*3.5; // move with half speed for the next half way
	}
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: In this function the robot will move to the range that we want it to go and it'll stop exactly there*/
void grab(int range) {
	if(rightPotentio > range) {
		motor[rightGrab] = abs(rightPotentio - range)/10;
		}else if (rightPotentio < range) {
		motor[rightGrab] = abs(rightPotentio - range)/-10;
	}
	if(leftPotentio > range) {
		motor[leftGrab] = abs(leftPotentio - range)/10;
		}else if (leftPotentio < range) {
		motor[leftGrab] = abs(leftPotentio - range)/-10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function is for lift the arm up and stay there it stays in the loop*/
void lift(int range, int speed) {
	if(SensorValue[shaft] < range) {
	  motor[Tright] = speed;
		motor[Bright] = speed;
		motor[Bleft] = speed;
		motor[Tleft] = speed;
	}else {
		motor[Tright] = 15;
		motor[Bright] = 15;
		motor[Bleft] = 15;
		motor[Tleft] = 15;
	}
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will grab the cube with both motors. Where "rnage" is for how much you want to each grab to move. And
"speed" is the speed of the arm to move*/
void grabClose(int range, int speed) {
	while(SensorValue[leftPotentiometer] > range + 50) {
	  grabValue(); // get the value of the potentiometer from the function call "getGrab"

		if(rightPotentio > range) {
			motor[rightGrab] = speed;
		}

		if(leftPotentio > range + 70) {
			motor[leftGrab] = speed;
		}
	}
	wait1Msec(200);
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will stuck the arm up there, untile the function turn false*/
void stopArm(int range) {
	if(SensorValue[shaft] > range) {
		motor[Tright] = 15;
		motor[Bright] = 15;
		motor[Bleft] = 15;
		motor[Tleft] = 15;
	}
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will stop the wheels*/
void stopWheels() {
	motor[leftMotor] = 0;
	motor[rightMotor]= 0;
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will stop the lift of the robot*/
void armNothing(int speed) {
	motor[Tright] = speed;
	motor[Bright] = speed;
	motor[Bleft] = speed;
	motor[Tleft] = speed;
}
/*****************************************************	CLOSE	 **********************************************************/

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: this loop run for the for move of the robot*/
void liftMove(int range) { // "range" is the grab input
	resetWheels(); //reset the wheels to "0"

	while(nMotorEncoder[leftMotor] < 1600) { //set the robot to 1500 counts of the robot
		x = nMotorEncoder[leftMotor];	//display the value of the encoder
		moving(1600, 127); // move the robot forward with the distance of 1500 counts and a speed of 100

	  grabValue(); // get the value of the potentiometer from the function call "getGrab"
		grab(range); // move to the grab position that we set
		lift(87, 70); // it'll lift the arm and stays there untile this loop is finish
	}
	stopWheels(); // Stop the motor
	wait1Msec(200); // Wait for the other program to run
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: In this fuction the robot will move directly untile the it greater than "range" */
void moveSim(int range, int speed) {
	resetWheels();
	while(abs(nMotorEncoder[rightMotor]) < range) {
		moving(range, speed * -1);
	}
	stopWheels(); // Stop the motor
	wait1Msec(200);
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: in this fuction the robot will turn at he range that you want. Where the "range" is how far you want the robot want
to move. And "speed" is the value of how far you want you robot to go*/
void rightTurn(int range, int speed) {
	resetWheels();
	while(abs(nMotorEncoder[rightMotor]) < range) {
		motor[leftMotor] = speed;
		motor[rightMotor]= speed * -1;
		}
	stopWheels(); // Stop the motor
	armNothing(-15); // the lift will equal to 0
	wait1Msec(500);
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will move to the cude and grab it. Where "rnage" is for how far you want your robot to move. And
"speed" is the speed of the robot to move*/
void cubeMove(int range, int speed) {
	resetWheels();
	while(nMotorEncoder[rightMotor] < range) {
		moving(range, speed);
	}
		stopWheels(); // Stop the motor
		wait1Msec(200);
}

/*De: In this code the robot will lift the arm while grabing and turning. Where "rnage" is for how far you want your
robot to move. And "speed" is the speed of the robot to move*/
void leftTurnLift(int range, int speed) {

	resetWheels();
	SensorValue[shaft] = 0;

	while(abs(nMotorEncoder[leftMotor]) < range) {
		if(SensorValue[shaft] < 105) {
			motor[Tright] = 127;
			motor[Bright] = 127;
			motor[Bleft] = 127;
			motor[Tleft] = 127;
		}else {
			motor[Tright] = 25;
			motor[Bright] = 25;
			motor[Bleft] = 25;
			motor[Tleft] = 25;
		}
		motor[leftMotor] = speed * -1;
		motor[rightMotor]= speed;
	}
	stopWheels(); // Stop the motor
	wait1Msec(100);
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This function will move forward and drop it after the it arrive our demand. Where "rnage" is for how far you want
your robot to move.*/
void moveDrop(int range) {
	resetWheels();
	while(nMotorEncoder[leftMotor] < range){
		moving(range, 90);
		if(SensorValue[shaft] > 80){
			motor[Tright] = 15;
			motor[Bright] = 15;
			motor[Bleft] = 15;
			motor[Tleft] = 15;
		}else {
			armNothing(0); // the lift will equal to 0
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------*/
/*De: This is where the robot release it's grab. Where "range" is where you want each grab to move to*/
void releaseGrab(int range){
	while(SensorValue[leftPotentiometer] < range){
		rightPotentio = SensorValue[rightPotentiometer];
		leftPotentio = SensorValue[leftPotentiometer];
		grab(range);
	}
}

void pre_auton()
{
	SensorValue[shaft] = 0;
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	liftMove(1800); // the robot will move to the fence while open it's arm and the grab
	moveSim(70, 40);
	rightTurn(360, 35);
	cubeMove(650, 127);
	grabClose(700, 65);
	leftTurnLift(200, 50);
	moveDrop(600);
	releaseGrab(1800);
  AutonomousCodePlaceholderForTesting();
}
task usercontrol()
{

  while (true)
  {
    UserControlCodePlaceholderForTesting();
  }
}
